\begin{problem}{只有一端开口的瓶子}{standard input}{standard output}{1 second}{128 megabytes}

    \textit{栈就是像“只有一端开口的瓶子”一样的数据结构，大家可以理解为一个头部固定的数组，无论是取出数字还是放入数字，你都只能在数组末尾那一端（称为栈顶）修改。}

    非常喜欢数据结构的周老师又在给新加入 ACM 俱乐部的小萌新们传授他的人生经验。

    这天，周老师得到了一个乱序的全排列。但是周老师不喜欢无序的东西，所以他总想要把这个序列弄成一个单调递增的新序列（即任意 $i<j$ 均满足 $p_i< p_j$）。但是他现在手里恰好只有一些简单的数据结构—— $k$ 个栈。这些栈一开始全都为空，周老师想要只通过 $3$ 种操作，把初始的序列变成有序的新序列：

    1. 取出序列当前的第一个数字，插入到第 $p$ 个栈的顶部：\texttt{push p}

    2. 取出第 $p$ 个栈的顶部数字，插入到新序列的末尾位置：\texttt{pop p}
    
    3. 取出第 $p$ 个栈的顶部数字，插入到第 $q$ 个栈的顶部：\texttt{move p q}

    周老师非常的睿智，他一下就想到了如果持有的栈个数大等于数字总个数（也就是 $k\ge n$），那么就一定可以完成这项排序工作。作为本次数据结构专题讲课的作业题，周老师想考考身为小萌新的你，至少需要多少个这样的栈才能把给定的初始序列变成有序的新序列呢？换句话说，周老师想知道 $k$ 的最小值 $\texttt{min}\{k\}$ 是多少。

    \InputFile
    
    第一行输入一个正整数 $T\ (1\le T\le 100)$，表示数据组数。
    
    接下来 $T$ 组数据，每组数据第一行输入一个正整数 $n\ (1\le n\le 10^5)$，表示本组数据输入的全排列序列长度。
     
    接下来一行输入 $n$ 个正整数 $p_1,p_2,\cdots,p_n$ 由空格间隔开，描述全排列序列 $P$ 的组成元素。输入保证 $[1,n]$ 中每个正整数在 $p_1,p_2,\cdots,p_n$ 中恰好只出现一次。 注意，该序列是有顺序的，操作 $1$ 只能从前往后取数字。

    \OutputFile
    
    对于每组数据，请输出一个正整数 $k$，表示至少需要 $k$ 个这样的栈才能把给定的初始序列变成有序的新序列，注意换行。

    
    \Example
    
    \begin{example}
    \exmp{
        3
        3
        3 2 1
        2
        1 2
        3
        2 3 1
    }{
        1
        1
        2
    }%
    \end{example}

    \Note
    \textbf{全排列：}全排列是由 $n$ 个数字组成的序列 $p_1,p_2,\cdots,p_n\ (p_i\in [1,n])$，其中数字 $1\cdots n$ 每个数字恰好只在 $p_i$ 中恰好只出现一次。

    \Explanation

    对于样例一，可行的方法是依次执行如下操作，即可只使用一个简单栈便处理完：
    
    \ \ \ \ \ \ \texttt{push 1} $\to$ \texttt{push 1} $\to$ \texttt{push 1} $\to$ \texttt{pop 1} $\to$ \texttt{pop 1} $\to$ \texttt{pop 1}

    对于样例二，可行的方法是依次执行如下操作，即可只使用一个简单栈便处理完：
    
    \ \ \ \ \ \ \texttt{push 1} $\to$ \texttt{pop 1} $\to$ \texttt{push 1} $\to$ \texttt{pop 1}

    对于样例三，显然一个栈无法处理，至少需要两个栈来处理：

    \ \ \ \ \ \ \texttt{push 1} $\to$ \texttt{push 1} $\to$ \texttt{move 1 2} $\to$ \texttt{move 1 2} $\to$ \texttt{push 2} $\to$ \texttt{pop 2} $\to$ \texttt{pop 2} $\to$ \texttt{pop 2}

\end{problem}